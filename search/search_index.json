{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SwervePy: The swerve library for Python","text":"<p>SwervePy is a library for swerve drive bases in FRC. This library is extendable to any drive base  type (coaxial, differential) or module configuration.  Motors, sensors, and swerve modules are interchangeable and easy to develop.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Reference</li> </ol>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#swervepy.subsystem.SwerveDrive","title":"<code>swervepy.subsystem.SwerveDrive(modules, gyro, max_velocity, max_angular_velocity, vision_pose_callback=lambda : None)</code>","text":"<p>             Bases: <code>Subsystem</code></p> <p>A Subsystem representing the serve drivetrain.</p> <p>Use the drive() method to drive the swerve base at a set of desired velocities. The method handles moving the individual swerve modules, so the user only needs to consider the movement of the chassis itself.</p> <p>Field relative control is an option available for controlling movement. Field relative uses a gyro sensor to lock the robot's translational movement to the field's x- and y-axis. Practically, when a driver pushes \"forward\" on the stick, the robot will always move forward relative to the field rather than relative to the chassis heading.</p> <p>Construct a swerve drivetrain as a Subsystem.</p> <p>Parameters:</p> Name Type Description Default <code>modules</code> <code>tuple[SwerveModule, ...]</code> <p>List of swerve modules</p> required <code>gyro</code> <code>Gyro</code> <p>A gyro sensor that provides a CCW+ heading reading of the chassis</p> required <code>max_velocity</code> <code>Quantity</code> <p>The actual maximum velocity of the robot</p> required <code>max_angular_velocity</code> <code>Quantity</code> <p>The actual maximum angular (turning) velocity of the robot</p> required <code>vision_pose_callback</code> <code>Callable[[Pose2d], Optional[Pose2d]]</code> <p>An optional method that returns the robot's pose derived from vision and takes the robot's current pose as its sole argument. This pose from this method is integrated into the robot's odometry.</p> <code>lambda : None</code> Source code in <code>swervepy\\subsystem.py</code> <pre><code>def __init__(\n    self,\n    modules: tuple[SwerveModule, ...],\n    gyro: Gyro,\n    max_velocity: Quantity,\n    max_angular_velocity: Quantity,\n    vision_pose_callback: Callable[[Pose2d], Optional[Pose2d]] = lambda _: None,\n):\n    \"\"\"\n    Construct a swerve drivetrain as a Subsystem.\n\n    :param modules: List of swerve modules\n    :param gyro: A gyro sensor that provides a CCW+ heading reading of the chassis\n    :param max_velocity: The actual maximum velocity of the robot\n    :param max_angular_velocity: The actual maximum angular (turning) velocity of the robot\n    :param vision_pose_callback: An optional method that returns the robot's pose derived from vision and takes the\n    robot's current pose as its sole argument. This pose from this method is integrated into the robot's odometry.\n    \"\"\"\n\n    super().__init__()\n\n    self._modules = modules\n    self._gyro = gyro\n    self._vision_pose_callback = vision_pose_callback\n    self.max_velocity: float = max_velocity.m_as(u.m / u.s)\n    self.max_angular_velocity: float = max_angular_velocity.m_as(u.rad / u.s)\n\n    # Pause init for a second before setting module offsets to avoid a bug related to inverting motors.\n    # Fixes https://github.com/Team364/BaseFalconSwerve/issues/8.\n    time.sleep(1)\n    self.reset_modules()\n\n    # Zero heading at startup to set \"forward\" direction\n    self.zero_heading()\n\n    # There are different classes for each number of swerve modules in a drive base,\n    # so construct the class name from number of modules.\n    self._kinematics: \"SwerveDrive4Kinematics\" = getattr(\n        wpimath.kinematics, f\"SwerveDrive{len(modules)}Kinematics\"\n    )(*[module.placement for module in self._modules])\n    self._odometry: \"SwerveDrive4PoseEstimator\" = getattr(\n        wpimath.estimator, f\"SwerveDrive{len(modules)}PoseEstimator\"\n    )(self._kinematics, self._gyro.heading, self.module_positions, Pose2d())\n\n    for i, module in enumerate(modules):\n        wpilib.SmartDashboard.putData(f\"Module {i}\", module)\n\n    # Field to plot auto trajectories and robot pose\n    self.field = wpilib.Field2d()\n    wpilib.SmartDashboard.putData(self.field)\n</code></pre>"},{"location":"reference/#swervepy.subsystem.SwerveDrive.heading","title":"<code>heading: Rotation2d</code>  <code>property</code>","text":"<p>The robot's facing direction</p>"},{"location":"reference/#swervepy.subsystem.SwerveDrive.module_positions","title":"<code>module_positions: tuple[SwerveModulePosition, ...]</code>  <code>property</code>","text":"<p>A tuple of the swerve modules' positions (driven distance and facing rotation)</p>"},{"location":"reference/#swervepy.subsystem.SwerveDrive.pose","title":"<code>pose: Pose2d</code>  <code>property</code>","text":"<p>The robot's pose on the field (position and heading)</p>"},{"location":"reference/#swervepy.subsystem.SwerveDrive.robot_relative_speeds","title":"<code>robot_relative_speeds: ChassisSpeeds</code>  <code>property</code>","text":"<p>The robot's translational and rotational speeds</p>"},{"location":"reference/#swervepy.subsystem.SwerveDrive._","title":"<code>_(chassis_speeds, drive_open_loop)</code>","text":"<p>Alternative method to drive the robot at a set of chassis speeds (exclusively robot-relative)</p> <p>Parameters:</p> Name Type Description Default <code>chassis_speeds</code> <code>ChassisSpeeds</code> <p>Robot-relative speeds on the XY-plane in m/s where +X is forward and +Y is left</p> required <code>drive_open_loop</code> <code>bool</code> <p>Use open loop (True) or closed loop (False) velocity control for driving the wheel</p> required Source code in <code>swervepy\\subsystem.py</code> <pre><code>@drive.register\ndef _(self, chassis_speeds: ChassisSpeeds, drive_open_loop: bool):\n    \"\"\"\n    Alternative method to drive the robot at a set of chassis speeds (exclusively robot-relative)\n\n    :param chassis_speeds: Robot-relative speeds on the XY-plane in m/s where +X is forward and +Y is left\n    :param drive_open_loop: Use open loop (True) or closed loop (False) velocity control for driving the wheel\n    \"\"\"\n\n    translation = Translation2d(chassis_speeds.vx, chassis_speeds.vy)\n    return self.drive(translation, chassis_speeds.omega, False, drive_open_loop)\n</code></pre>"},{"location":"reference/#swervepy.subsystem.SwerveDrive.desire_module_states","title":"<code>desire_module_states(states, drive_open_loop=False, rotate_in_place=True)</code>","text":"<p>Command each individual module to a state (consisting of velocity and rotation)</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>tuple[SwerveModuleState, ...]</code> <p>List of module states in the order of the swerve module list SwerveDrive was created with</p> required <code>drive_open_loop</code> <code>bool</code> <p>Use open loop (True) or closed loop (False) velocity control for driving the wheel</p> <code>False</code> <code>rotate_in_place</code> <code>bool</code> <p>Should the modules rotate while not driving</p> <code>True</code> Source code in <code>swervepy\\subsystem.py</code> <pre><code>def desire_module_states(\n    self,\n    states: tuple[SwerveModuleState, ...],\n    drive_open_loop: bool = False,\n    rotate_in_place: bool = True,\n):\n    \"\"\"\n    Command each individual module to a state (consisting of velocity and rotation)\n\n    :param states: List of module states in the order of the swerve module list SwerveDrive was created with\n    :param drive_open_loop: Use open loop (True) or closed loop (False) velocity control for driving the wheel\n    :param rotate_in_place: Should the modules rotate while not driving\n    \"\"\"\n\n    swerve_module_states = self._kinematics.desaturateWheelSpeeds(states, self.max_velocity)  # type: ignore\n\n    for i in range(len(self._modules)):\n        module: SwerveModule = self._modules[i]\n        module.desire_state(swerve_module_states[i], drive_open_loop, rotate_in_place)\n</code></pre>"},{"location":"reference/#swervepy.subsystem.SwerveDrive.drive","title":"<code>drive(translation, rotation, field_relative, drive_open_loop)</code>","text":"<p>Drive the robot at the provided speeds (translation and rotation)</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>Translation2d</code> <p>Translation speed on the XY-plane in m/s where +X is forward and +Y is left</p> required <code>rotation</code> <code>float</code> <p>Rotation speed around the Z-axis in rad/s where CCW+</p> required <code>field_relative</code> <code>bool</code> <p>If True, gyroscopic zero is used as the forward direction. Else, forward faces the front of the robot.</p> required <code>drive_open_loop</code> <code>bool</code> <p>Use open loop (True) or closed loop (False) velocity control for driving the wheel</p> required Source code in <code>swervepy\\subsystem.py</code> <pre><code>@singledispatchmethod\ndef drive(\n    self,\n    translation: Translation2d,\n    rotation: float,\n    field_relative: bool,\n    drive_open_loop: bool,\n):\n    \"\"\"\n    Drive the robot at the provided speeds (translation and rotation)\n\n    :param translation: Translation speed on the XY-plane in m/s where +X is forward and +Y is left\n    :param rotation: Rotation speed around the Z-axis in rad/s where CCW+\n    :param field_relative: If True, gyroscopic zero is used as the forward direction.\n    Else, forward faces the front of the robot.\n    :param drive_open_loop: Use open loop (True) or closed loop (False) velocity control for driving the wheel\n    \"\"\"\n\n    speeds = (\n        ChassisSpeeds.fromFieldRelativeSpeeds(translation.x, translation.y, rotation, self._gyro.heading)\n        if field_relative\n        else ChassisSpeeds(translation.x, translation.y, rotation)\n    )\n    swerve_module_states = self._kinematics.toSwerveModuleStates(speeds)\n\n    self.desire_module_states(swerve_module_states, drive_open_loop, rotate_in_place=False)\n</code></pre>"},{"location":"reference/#swervepy.subsystem.SwerveDrive.follow_trajectory_command","title":"<code>follow_trajectory_command(path, parameters, first_path=False, drive_open_loop=False)</code>","text":"<p>Construct a command that follows a trajectory</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathPlannerPath</code> <p>The path to follow</p> required <code>parameters</code> <code>TrajectoryFollowerParameters</code> <p>Options that determine how the robot will follow the trajectory</p> required <code>first_path</code> <code>bool</code> <p>If True, the robot's pose will be reset to the trajectory's initial pose</p> <code>False</code> <code>drive_open_loop</code> <code>bool</code> <p>Use open loop control (True) or closed loop (False) to swerve module speeds. Closed-loop positional control will always be used for trajectory following</p> <code>False</code> <p>Returns:</p> Type Description <code>Command</code> <p>Trajectory-follower command</p> Source code in <code>swervepy\\subsystem.py</code> <pre><code>def follow_trajectory_command(\n    self,\n    path: PathPlannerPath,\n    parameters: \"TrajectoryFollowerParameters\",\n    first_path: bool = False,\n    drive_open_loop: bool = False,\n) -&gt; commands2.Command:\n    \"\"\"\n    Construct a command that follows a trajectory\n\n    :param path: The path to follow\n    :param parameters: Options that determine how the robot will follow the trajectory\n    :param first_path: If True, the robot's pose will be reset to the trajectory's initial pose\n    :param drive_open_loop: Use open loop control (True) or closed loop (False) to swerve module speeds. Closed-loop\n    positional control will always be used for trajectory following\n    :return: Trajectory-follower command\n    \"\"\"\n\n    # TODO: Re-impl trajectory visualisation on Field2d\n\n    # Find the drive base radius (the distance from the center of the robot to the furthest module)\n    radius = greatest_distance_from_translations([module.placement for module in self._modules])\n\n    # Position feedback controller for following waypoints\n    controller = PPHolonomicDriveController(\n        PIDConstants(parameters.xy_kP),\n        PIDConstants(parameters.theta_kP),\n        parameters.max_drive_velocity.m_as(u.m / u.s),\n        radius,\n    )\n\n    # Trajectory follower command\n    command = FollowPathWithEvents(\n        FollowPathCommand(\n            path,\n            lambda: self.pose,\n            lambda: self.robot_relative_speeds,\n            lambda speeds: self.drive(speeds, drive_open_loop=drive_open_loop),\n            controller,\n            ReplanningConfig(),\n            self,\n        ),\n        path,\n        lambda: self.pose,\n    )\n\n    # If this is the first path in a sequence, reset the robot's pose so that it aligns with the start of the path\n    if first_path:\n        initial_pose = path.getPreviewStartingHolonomicPose()\n        command = command.beforeStarting(commands2.InstantCommand(lambda: self.reset_odometry(initial_pose)))\n\n    return command\n</code></pre>"},{"location":"reference/#swervepy.subsystem.SwerveDrive.reset_odometry","title":"<code>reset_odometry(pose)</code>","text":"<p>Reset the drive base's pose to a new one</p> <p>Parameters:</p> Name Type Description Default <code>pose</code> <code>Pose2d</code> <p>The new pose</p> required Source code in <code>swervepy\\subsystem.py</code> <pre><code>def reset_odometry(self, pose: Pose2d):\n    \"\"\"\n    Reset the drive base's pose to a new one\n\n    :param pose: The new pose\n    \"\"\"\n\n    self._odometry.resetPosition(self._gyro.heading, self.module_positions, pose)  # type: ignore\n</code></pre>"},{"location":"reference/#swervepy.subsystem.SwerveDrive.teleop_command","title":"<code>teleop_command(translation, strafe, rotation, field_relative, drive_open_loop)</code>","text":"<p>Construct a command that drives the robot using joystick (or other) inputs</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>Callable[[], float]</code> <p>A method that returns the desired +X (forward/backward) velocity in m/s</p> required <code>strafe</code> <code>Callable[[], float]</code> <p>A method that returns the desired +Y (left/right) velocity in m/s</p> required <code>rotation</code> <code>Callable[[], float]</code> <p>A method that returns the desired CCW+ rotational velocity in rad/s</p> required <code>field_relative</code> <code>bool</code> <p>If True, gyroscopic zero is used as the forward direction. Else, forward faces the front of the robot.</p> required <code>drive_open_loop</code> <code>bool</code> <p>Use open loop (True) or closed loop (False) velocity control for driving the wheel</p> required <p>Returns:</p> Type Description <code>Command</code> <p>The command</p> Source code in <code>swervepy\\subsystem.py</code> <pre><code>def teleop_command(\n    self,\n    translation: Callable[[], float],\n    strafe: Callable[[], float],\n    rotation: Callable[[], float],\n    field_relative: bool,\n    drive_open_loop: bool,\n) -&gt; commands2.Command:\n    \"\"\"\n    Construct a command that drives the robot using joystick (or other) inputs\n\n    :param translation: A method that returns the desired +X (forward/backward) velocity in m/s\n    :param strafe: A method that returns the desired +Y (left/right) velocity in m/s\n    :param rotation: A method that returns the desired CCW+ rotational velocity in rad/s\n    :param field_relative: If True, gyroscopic zero is used as the forward direction.\n    Else, forward faces the front of the robot.\n    :param drive_open_loop: Use open loop (True) or closed loop (False) velocity control for driving the wheel\n    :return: The command\n    \"\"\"\n    return _TeleOpCommand(self, translation, strafe, rotation, field_relative, drive_open_loop)\n</code></pre>"},{"location":"reference/#swervepy.subsystem.SwerveDrive.zero_heading","title":"<code>zero_heading()</code>","text":"<p>Set the chassis' current heading as \"zero\" or straight forward</p> Source code in <code>swervepy\\subsystem.py</code> <pre><code>def zero_heading(self):\n    \"\"\"Set the chassis' current heading as \"zero\" or straight forward\"\"\"\n    self._gyro.zero_heading()\n</code></pre>"},{"location":"reference/#swervepy.abstract","title":"<code>swervepy.abstract</code>","text":"<p>Contains interfaces for components used in a swerve drive base. These are sensors, motors, and the swerve module itself. Implementations can be found in the impl module, or the user may define their own.</p>"},{"location":"reference/#swervepy.abstract.AbsoluteEncoder","title":"<code>AbsoluteEncoder</code>","text":"<p>             Bases: <code>Sendable</code></p>"},{"location":"reference/#swervepy.abstract.AbsoluteEncoder.absolute_position","title":"<code>absolute_position: Rotation2d</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Absolute rotation</p>"},{"location":"reference/#swervepy.abstract.CoaxialAzimuthComponent","title":"<code>CoaxialAzimuthComponent</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>The component of a swerve module that turns the wheel. This component also initializes the wheel to its absolute position (usually via an absolute encoder).</p>"},{"location":"reference/#swervepy.abstract.CoaxialAzimuthComponent.angle","title":"<code>angle: Rotation2d</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>The wheel angle</p>"},{"location":"reference/#swervepy.abstract.CoaxialAzimuthComponent.rotational_velocity","title":"<code>rotational_velocity: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Rotational velocity in rad/s</p>"},{"location":"reference/#swervepy.abstract.CoaxialAzimuthComponent.follow_angle","title":"<code>follow_angle(angle)</code>  <code>abstractmethod</code>","text":"<p>Move the wheel to an angle</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Rotation2d</code> <p>The desired wheel angle</p> required Source code in <code>swervepy\\abstract\\motor.py</code> <pre><code>@abstractmethod\ndef follow_angle(self, angle: Rotation2d):\n    \"\"\"\n    Move the wheel to an angle\n\n    :param angle: The desired wheel angle\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#swervepy.abstract.CoaxialAzimuthComponent.reset","title":"<code>reset()</code>  <code>abstractmethod</code>","text":"<p>Reset the wheel's angle to its absolute position</p> Source code in <code>swervepy\\abstract\\motor.py</code> <pre><code>@abstractmethod\ndef reset(self):\n    \"\"\"Reset the wheel's angle to its absolute position\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#swervepy.abstract.CoaxialDriveComponent","title":"<code>CoaxialDriveComponent</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>The component of a swerve module that drives the wheel (forward and backward)</p>"},{"location":"reference/#swervepy.abstract.CoaxialDriveComponent.distance","title":"<code>distance: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Driven distance in metres</p>"},{"location":"reference/#swervepy.abstract.CoaxialDriveComponent.velocity","title":"<code>velocity: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Drive velocity in m/s</p>"},{"location":"reference/#swervepy.abstract.CoaxialDriveComponent.follow_velocity_closed","title":"<code>follow_velocity_closed(velocity)</code>  <code>abstractmethod</code>","text":"<p>Follow a velocity using closed loop control (i.e., PID)</p> <p>Parameters:</p> Name Type Description Default <code>velocity</code> <code>float</code> <p>Desired velocity in m/s</p> required Source code in <code>swervepy\\abstract\\motor.py</code> <pre><code>@abstractmethod\ndef follow_velocity_closed(self, velocity: float):\n    \"\"\"\n    Follow a velocity using closed loop control (i.e., PID)\n\n    :param velocity: Desired velocity in m/s\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#swervepy.abstract.CoaxialDriveComponent.follow_velocity_open","title":"<code>follow_velocity_open(velocity)</code>  <code>abstractmethod</code>","text":"<p>Follow a velocity using open loop control</p> <p>Parameters:</p> Name Type Description Default <code>velocity</code> <code>float</code> <p>Desired velocity in m/s</p> required Source code in <code>swervepy\\abstract\\motor.py</code> <pre><code>@abstractmethod\ndef follow_velocity_open(self, velocity: float):\n    \"\"\"\n    Follow a velocity using open loop control\n\n    :param velocity: Desired velocity in m/s\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#swervepy.abstract.CoaxialDriveComponent.reset","title":"<code>reset()</code>  <code>abstractmethod</code>","text":"<p>Reset driven distance to zero or otherwise reinitialize the motor</p> Source code in <code>swervepy\\abstract\\motor.py</code> <pre><code>@abstractmethod\ndef reset(self):\n    \"\"\"Reset driven distance to zero or otherwise reinitialize the motor\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#swervepy.abstract.Gyro","title":"<code>Gyro</code>","text":"<p>             Bases: <code>Sendable</code></p>"},{"location":"reference/#swervepy.abstract.Gyro.heading","title":"<code>heading: Rotation2d</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>CCW+ chassis yaw angle</p>"},{"location":"reference/#swervepy.abstract.Gyro.zero_heading","title":"<code>zero_heading()</code>  <code>abstractmethod</code>","text":"<p>Set the gyro sensor's current heading as zero</p> Source code in <code>swervepy\\abstract\\sensor.py</code> <pre><code>@abstractmethod\ndef zero_heading(self):\n    \"\"\"Set the gyro sensor's current heading as zero\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#swervepy.abstract.SwerveModule","title":"<code>SwerveModule</code>","text":"<p>             Bases: <code>Sendable</code></p>"},{"location":"reference/#swervepy.abstract.SwerveModule.azimuth_angle","title":"<code>azimuth_angle: Rotation2d</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>CCW+ wheel angle</p>"},{"location":"reference/#swervepy.abstract.SwerveModule.azimuth_velocity","title":"<code>azimuth_velocity: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>CCW+ wheel angular velocity in rad/s</p>"},{"location":"reference/#swervepy.abstract.SwerveModule.drive_distance","title":"<code>drive_distance: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Driven distance in metres</p>"},{"location":"reference/#swervepy.abstract.SwerveModule.drive_velocity","title":"<code>drive_velocity: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Drive wheel velocity in m/s</p>"},{"location":"reference/#swervepy.abstract.SwerveModule.module_position","title":"<code>module_position: SwerveModulePosition</code>  <code>property</code>","text":"<p>The swerve module's driven distance (in metres) and facing angle</p>"},{"location":"reference/#swervepy.abstract.SwerveModule.module_state","title":"<code>module_state: SwerveModuleState</code>  <code>property</code>","text":"<p>The swerve module's current velocity (in metres/sec) and facing angle</p>"},{"location":"reference/#swervepy.abstract.SwerveModule.desire_azimuth_angle","title":"<code>desire_azimuth_angle(angle)</code>  <code>abstractmethod</code>","text":"<p>Turn the wheel</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Rotation2d</code> <p>Desired facing angle of the wheel</p> required Source code in <code>swervepy\\abstract\\system.py</code> <pre><code>@abstractmethod\ndef desire_azimuth_angle(self, angle: Rotation2d):\n    \"\"\"\n    Turn the wheel\n\n    :param angle: Desired facing angle of the wheel\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#swervepy.abstract.SwerveModule.desire_drive_velocity","title":"<code>desire_drive_velocity(velocity, open_loop)</code>  <code>abstractmethod</code>","text":"<p>Drive the wheel</p> <p>Parameters:</p> Name Type Description Default <code>velocity</code> <code>float</code> <p>Desired velocity in m/s</p> required <code>open_loop</code> <code>bool</code> <p>Use open loop (True) or closed loop (False) velocity control</p> required Source code in <code>swervepy\\abstract\\system.py</code> <pre><code>@abstractmethod\ndef desire_drive_velocity(self, velocity: float, open_loop: bool):\n    \"\"\"\n    Drive the wheel\n\n    :param velocity: Desired velocity in m/s\n    :param open_loop: Use open loop (True) or closed loop (False) velocity control\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#swervepy.abstract.SwerveModule.desire_state","title":"<code>desire_state(state, drive_open_loop, rotate_in_place)</code>","text":"<p>Command the module to follow a speed and angle</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>SwerveModuleState</code> <p>SwerveModuleState representing the module's desired speed and angle</p> required <code>drive_open_loop</code> <code>bool</code> <p>Use open loop (True) or closed loop (False) velocity control to drive the wheel</p> required <code>rotate_in_place</code> <code>bool</code> <p>Whether the modules will rotate while not driving. Set False to prevent wheels from wearing down by spinning in place</p> required Source code in <code>swervepy\\abstract\\system.py</code> <pre><code>def desire_state(self, state: SwerveModuleState, drive_open_loop: bool, rotate_in_place: bool):\n    \"\"\"\n    Command the module to follow a speed and angle\n\n    :param state: SwerveModuleState representing the module's desired speed and angle\n    :param drive_open_loop: Use open loop (True) or closed loop (False) velocity control to drive the wheel\n    :param rotate_in_place: Whether the modules will rotate while not driving. Set False to prevent wheels from\n    wearing down by spinning in place\n    \"\"\"\n    state = optimize(state, self.azimuth_angle)\n\n    # Prevent rotating the module if drive speed is less than 2 cm/s to prevent feedback-loop jitter\n    angle = state.angle if rotate_in_place or abs(state.speed) &gt; 0.02 else self.azimuth_angle\n\n    self.desire_drive_velocity(state.speed, drive_open_loop)\n    self.desire_azimuth_angle(angle)\n</code></pre>"},{"location":"reference/#swervepy.abstract.SwerveModule.reset","title":"<code>reset()</code>  <code>abstractmethod</code>","text":"<p>Reset sensor readings. Should be called during initialization.</p> Source code in <code>swervepy\\abstract\\system.py</code> <pre><code>@abstractmethod\ndef reset(self):\n    \"\"\"Reset sensor readings. Should be called during initialization.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/#swervepy.impl","title":"<code>swervepy.impl</code>","text":"<p>Contains default implementations of components (motors, sensors, modules). The user should instantiate these when creating their drive base.</p>"},{"location":"reference/#swervepy.impl.AbsoluteCANCoder","title":"<code>AbsoluteCANCoder(id_)</code>","text":"<p>             Bases: <code>AbsoluteEncoder</code></p> Source code in <code>swervepy\\impl\\sensor.py</code> <pre><code>def __init__(self, id_: int | tuple[int, str]):\n    super().__init__()\n\n    # Construct the CANCoder from either a tuple of motor ID and CAN bus ID or just a motor ID\n    try:\n        self._encoder = phoenix5.sensors.CANCoder(*id_)\n    except TypeError:\n        self._encoder = phoenix5.sensors.CANCoder(id_)\n\n    self._encoder.configAbsoluteSensorRange(phoenix5.sensors.AbsoluteSensorRange.Unsigned_0_to_360)\n\n    wpilib.SmartDashboard.putData(f\"Absolute CANCoder {id_}\", self)\n</code></pre>"},{"location":"reference/#swervepy.impl.AbsoluteDutyCycleEncoder","title":"<code>AbsoluteDutyCycleEncoder(dio_pin)</code>","text":"<p>             Bases: <code>AbsoluteEncoder</code></p> Source code in <code>swervepy\\impl\\sensor.py</code> <pre><code>def __init__(self, dio_pin: int):\n    super().__init__()\n\n    self._encoder = wpilib.DutyCycleEncoder(dio_pin)\n    wpilib.SmartDashboard.putData(f\"Absolute PWM Encoder {dio_pin}\", self)\n</code></pre>"},{"location":"reference/#swervepy.impl.CoaxialSwerveModule","title":"<code>CoaxialSwerveModule(drive, azimuth, placement)</code>","text":"<p>             Bases: <code>SwerveModule</code></p> Source code in <code>swervepy\\impl\\system.py</code> <pre><code>def __init__(self, drive: CoaxialDriveComponent, azimuth: CoaxialAzimuthComponent, placement: Translation2d):\n    super().__init__()\n\n    self._drive = drive\n    self._azimuth = azimuth\n    self.placement = placement\n</code></pre>"},{"location":"reference/#swervepy.impl.DummyCoaxialComponent","title":"<code>DummyCoaxialComponent(*args)</code>","text":"<p>             Bases: <code>CoaxialDriveComponent</code>, <code>CoaxialAzimuthComponent</code></p> <p>Coaxial drive or azimuth component that does nothing</p> Source code in <code>swervepy\\impl\\motor.py</code> <pre><code>def __init__(self, *args):\n    pass\n</code></pre>"},{"location":"reference/#swervepy.impl.DummyGyro","title":"<code>DummyGyro(*args)</code>","text":"<p>             Bases: <code>Gyro</code></p> <p>Gyro that does nothing</p> Source code in <code>swervepy\\impl\\sensor.py</code> <pre><code>def __init__(self, *args):\n    super().__init__()\n</code></pre>"},{"location":"reference/#swervepy.impl.Falcon500CoaxialAzimuthComponent","title":"<code>Falcon500CoaxialAzimuthComponent(id_, azimuth_offset, parameters, absolute_encoder)</code>","text":"<p>             Bases: <code>CoaxialAzimuthComponent</code></p> Source code in <code>swervepy\\impl\\motor.py</code> <pre><code>def __init__(\n    self,\n    id_: int | tuple[int, str],\n    azimuth_offset: Rotation2d,\n    parameters: Parameters,\n    absolute_encoder: AbsoluteEncoder,\n):\n    self._params = parameters.in_standard_units()\n\n    try:\n        # Unpack tuple of motor id and CAN bus id into TalonFX constructor\n        self._motor = phoenix5.TalonFX(*id_)\n    except TypeError:\n        # Only an int was provided for id_\n        self._motor = phoenix5.TalonFX(id_)\n\n    self._absolute_encoder = absolute_encoder\n    self._offset = azimuth_offset\n\n    self._config()\n    self.reset()\n</code></pre>"},{"location":"reference/#swervepy.impl.Falcon500CoaxialDriveComponent","title":"<code>Falcon500CoaxialDriveComponent(id_, parameters)</code>","text":"<p>             Bases: <code>CoaxialDriveComponent</code></p> Source code in <code>swervepy\\impl\\motor.py</code> <pre><code>def __init__(self, id_: int | tuple[int, str], parameters: Parameters):\n    self._params = parameters.in_standard_units()\n\n    try:\n        # Unpack tuple of motor id and CAN bus id into TalonFX constructor\n        self._motor = phoenix5.TalonFX(*id_)\n    except TypeError:\n        # Only an int was provided for id_\n        self._motor = phoenix5.TalonFX(id_)\n\n    self._config()\n    self.reset()\n\n    self._feedforward = SimpleMotorFeedforwardMeters(parameters.kS, parameters.kV, parameters.kA)\n</code></pre>"},{"location":"reference/#swervepy.impl.NEOCoaxialAzimuthComponent","title":"<code>NEOCoaxialAzimuthComponent(id_, azimuth_offset, parameters, absolute_encoder)</code>","text":"<p>             Bases: <code>CoaxialAzimuthComponent</code></p> Source code in <code>swervepy\\impl\\motor.py</code> <pre><code>def __init__(\n    self,\n    id_: int,\n    azimuth_offset: Rotation2d,\n    parameters: Parameters,\n    absolute_encoder: AbsoluteEncoder | SparkMaxEncoderType,\n):\n    self._params = parameters.in_standard_units()\n\n    self._motor = rev.CANSparkMax(id_, rev.CANSparkMax.MotorType.kBrushless)\n    self._controller = self._motor.getPIDController()\n    self._encoder = self._motor.getEncoder()\n\n    # Config must be called before the absolute encoder is set up because config method\n    # factory resets the SPARK MAX\n    self._config()\n\n    if isinstance(absolute_encoder, SparkMaxEncoderType):\n        # Construct an AbsoluteEncoder from sensor plugged into SPARK MAX\n        self._absolute_encoder = SparkMaxAbsoluteEncoder(self._motor, absolute_encoder)\n    else:\n        self._absolute_encoder = absolute_encoder\n\n    self._offset = azimuth_offset\n\n    self.reset()\n</code></pre>"},{"location":"reference/#swervepy.impl.NEOCoaxialDriveComponent","title":"<code>NEOCoaxialDriveComponent(id_, parameters)</code>","text":"<p>             Bases: <code>CoaxialDriveComponent</code></p> Source code in <code>swervepy\\impl\\motor.py</code> <pre><code>def __init__(self, id_: int, parameters: Parameters):\n    self._params = parameters.in_standard_units()\n\n    self._motor = rev.CANSparkMax(id_, rev.CANSparkMax.MotorType.kBrushless)\n    self._controller = self._motor.getPIDController()\n    self._encoder = self._motor.getEncoder()\n    self._config()\n    self.reset()\n\n    self._feedforward = SimpleMotorFeedforwardMeters(parameters.kS, parameters.kV, parameters.kA)\n</code></pre>"},{"location":"reference/#swervepy.impl.PigeonGyro","title":"<code>PigeonGyro(id_, invert=False)</code>","text":"<p>             Bases: <code>Gyro</code></p> Source code in <code>swervepy\\impl\\sensor.py</code> <pre><code>def __init__(self, id_: int, invert: bool = False):\n    super().__init__()\n\n    self._gyro = phoenix5.sensors.PigeonIMU(id_)\n    self.invert = invert\n\n    wpilib.SmartDashboard.putData(\"Pigeon IMU\", self)\n</code></pre>"},{"location":"reference/#swervepy.impl.SparkMaxAbsoluteEncoder","title":"<code>SparkMaxAbsoluteEncoder(controller, encoder_type)</code>","text":"<p>             Bases: <code>AbsoluteEncoder</code></p> <p>Absolute encoder plugged into the SPARK MAX's data port</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>CANSparkMax</code> <p>SPARK MAX instance</p> required <code>encoder_type</code> <code>SparkMaxEncoderType</code> <p>Type of encoder plugged in. Based on how the encoder transmits data</p> required Source code in <code>swervepy\\impl\\sensor.py</code> <pre><code>def __init__(self, controller: rev.CANSparkMax, encoder_type: SparkMaxEncoderType):\n    \"\"\"\n    Absolute encoder plugged into the SPARK MAX's data port\n\n    :param controller: SPARK MAX instance\n    :param encoder_type: Type of encoder plugged in. Based on how the encoder transmits data\n    \"\"\"\n\n    super().__init__()\n\n    # Two types of absolute encoders can be plugged into the SPARK MAX data port: analog and duty cycle/PWM\n    if encoder_type is SparkMaxEncoderType.ANALOG:\n        self._encoder = controller.getAnalog(rev.SparkMaxAnalogSensor.Mode.kAbsolute)\n\n        # Analog encoders output from 0V - 3.3V\n        # Change from voltage to degrees\n        self._encoder.setPositionConversionFactor(360 / 3.3)\n    elif encoder_type is SparkMaxEncoderType.PWM:\n        self._encoder = controller.getAbsoluteEncoder(rev.SparkMaxAbsoluteEncoder.Type.kDutyCycle)\n\n        # Duty cycle encoders output from 0 to 1 by default\n        # Change into degrees\n        self._encoder.setPositionConversionFactor(360)\n\n    wpilib.SmartDashboard.putData(f\"Absolute Encoder {controller.getDeviceId()}\", self)\n</code></pre>"},{"location":"reference/#swervepy.impl.SparkMaxEncoderType","title":"<code>SparkMaxEncoderType</code>","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"reference/#swervepy.impl.SparkMaxEncoderType.ANALOG","title":"<code>ANALOG = enum.auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/#swervepy.impl.SparkMaxEncoderType.PWM","title":"<code>PWM = enum.auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""}]}